# ADR-003: No Code Regions

**Status**: Accepted
**Date**: 2025-11-02
**Context**: C# code organization and maintainability

## Decision

The use of `#region` and `#endregion` directives is prohibited in all C# source files.

## Rationale

### Problems with Regions

1. **Hides Complexity**: Regions collapse code blocks, hiding complexity instead of addressing it through proper design
2. **False Organization**: If a class needs regions to be organized, it likely violates Single Responsibility Principle
3. **Navigation Overhead**: Constantly expanding/collapsing regions disrupts development flow
4. **Refactoring Indicator**: Need for regions signals that code should be split into smaller classes
5. **Modern IDE Features**: Code outline views, search, and navigation make regions obsolete

### Better Alternatives

- **Extract Classes**: Split large classes into focused, single-responsibility classes
- **Extract Methods**: Break down complex methods into smaller, named methods
- **Namespaces**: Use namespace organization for logical grouping
- **Partial Classes**: Only when required by code generation (e.g., UI designers)
- **File Organization**: Use directories and file structure for organization

## Examples

### BAD: Using Regions to Organize

```csharp
public class MassiveService
{
    #region Fields
    private readonly IDependency1 _dep1;
    private readonly IDependency2 _dep2;
    // ... 10 more fields
    #endregion

    #region Constructor
    public MassiveService(/* 12 dependencies */) { }
    #endregion

    #region Public Methods
    public void DoSomething() { /* 50 lines */ }
    public void DoSomethingElse() { /* 50 lines */ }
    #endregion

    #region Private Methods
    private void HelperMethod1() { /* 30 lines */ }
    private void HelperMethod2() { /* 30 lines */ }
    #endregion
}
```

### GOOD: Proper Class Decomposition

```csharp
// Split into focused services
public class ServicePartA
{
    private readonly IDependency1 _dep1;

    public ServicePartA(IDependency1 dep1)
    {
        _dep1 = dep1;
    }

    public void DoSomething()
    {
        // Focused logic
    }
}

public class ServicePartB
{
    private readonly IDependency2 _dep2;

    public ServicePartB(IDependency2 dep2)
    {
        _dep2 = dep2;
    }

    public void DoSomethingElse()
    {
        // Focused logic
    }
}
```

## Exceptions

**ONLY** acceptable use of regions:
- **Designer-Generated Code**: Visual Studio designer files (e.g., `.Designer.cs` files)
- **Auto-Generated Code**: Code generated by tools where regions are automatically created

**Human-Written Code**: Regions are NEVER acceptable in manually written code.

**Test Files**: Test files are NOT exempt. Regions in test files violate this ADR just like production code. Use descriptive test class names and method names instead of organizing with regions.

## Consequences

### Positive
- Forces proper class decomposition and adherence to Single Responsibility Principle
- Improves code readability and maintainability
- Reduces cognitive load when navigating code
- Encourages smaller, focused classes that are easier to test
- Eliminates "god classes" that try to do too much

### Negative
- May require more initial effort to properly decompose classes
- Developers accustomed to regions need to adapt to better practices
- Legacy code migration requires refactoring rather than simple cleanup

## Enforcement

1. **Pre-Commit Hook**: Automated validation blocks commits with `#region` directives
   - Run: `./scripts/validate-no-regions.ps1`
   - Installed via: `./scripts/install-pre-commit-hook.ps1`
2. **Code Review**: Reviewers reject PRs containing `#region` directives in non-generated code
3. **Static Analysis**: `.editorconfig` configured with IDE0055 warning
4. **Documentation**: This ADR linked in CLAUDE.md coding guidelines
5. **Cleanup Tool**: Use `./scripts/remove-regions.ps1` to automatically remove all regions

## Migration Strategy

When encountering regions in existing code:
1. **Assess Class Size**: If >200 lines, plan decomposition
2. **Identify Responsibilities**: Find distinct concerns within the class
3. **Extract Services**: Create focused classes for each responsibility
4. **Update IoC**: Register new services with appropriate lifetimes
5. **Update Tests**: Split tests to match new class structure
6. **Remove Regions**: Delete region directives as part of refactoring
7. **Verify**: Ensure functionality unchanged through testing
